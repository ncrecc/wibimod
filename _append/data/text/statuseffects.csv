Name,Displayed As,Symbol,Description,Comment,Stacks?,Remove at End Turn?,Remove at Start Turn?,Invisible?,Blocked by Reduce?,Script: When inflicted,Script: On any status infliction,Script: Before Start Turn,Script: On Start Turn,Script: On any equipment use,Script: On any countdown reduce,Script: End Turn,Script: After Combat,Script: On damage inflicted,Script: On damage taken,Script: On status remove
ncr_jumble,Jumble,weaken,Your cards' slots are mixed up.,,NO,YES,NO,NO,YES,,,,sfx(~apply_weaken_to_equipment~); var indices = []; var shuffledindices = []; for(eq in self.equipment) { if(eq.isready() && eq.skillcard == ~~) { indices.push(self.equipment.indexOf(eq)); } }   shuffledindices = shuffle(indices.copy());  self.setvar(~jumbleindices~|indices); self.setvar(~jumbleshuffledindices~|shuffledindices);  self.setvar(~jumbleequipmentnames~|[for(eq in self.equipment) eq.name]); var indicessame = true; for(indice in shuffledindices) { if(shuffledindices[indices.indexOf(indice)] != indice) { indicessame = false; break; } } if(indicessame) { shuffledindices.unshift(shuffledindices.pop()); } /*there are people who are going to read this and cry*/ trace(indices); trace(shuffledindices);   var slotlist = []; var cdlist = []; var i = 0;  for(indice in indices) { slotlist.push(self.equipment[indice].getslots()); cdlist.push(self.equipment[indice].remainingcountdown); }  trace(indices); trace(shuffledindices); trace(slotlist); trace(cdlist);  for(indice in shuffledindices) { var eq = self.equipment[indice]; eq.changeslots(slotlist[i]); eq.remainingcountdown = cdlist[i]; eq.animate(~flashandshake~); eq.animation[eq.animation.length - 1].addcommand(~textparticle~[;] ~[weaken] Jumbled!~[;] 14519873); i++; },,,for(eq in self.equipment) eq.resetslots(); /*this probably does some unsatisfying stuff with equipment that modifies its own slot; but no enemies have those and how the hell would this get inflicted on the player before their turn starts*/ /*var names = self.getvar(~jumbleequipmentnames~); var indices = self.getvar(~jumbleindices~); var shuffledindices = self.getvar(~jumbleshuffledindices~); var slotlist = []; var cdlist = []; var i = 0;  for(indice in shuffledindices) { slotlist.push(self.equipment[indice].getslots()); cdlist.push(self.equipment[indice].remainingcountdown); }  for(indice in indices) { var eq = self.equipment[indice]; eq.changeslots(slotlist[i]); eq.remainingcountdown = cdlist[i]; if(eq.name != names[self.equipment.indexOf(eq)]) { eq.resetslots(); eq.remainingcountdown = eq.countdown; } i++; }*/,,,,
ncr_lightswitch1,Light_Switch_1,dice,Roll an extra 1 next turn.,,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch2,Light_Switch_2,dice,Roll an extra 2 next turn.,,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch3,Light_Switch_3,dice,Roll an extra 3 next turn.,,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch4,Light_Switch_4,dice,Roll an extra 4 next turn.,,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch5,Light_Switch_5,dice,Roll an extra 5 next turn.,,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch6,Light_Switch_6,dice,Roll an extra 6 next turn.,,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_silence,Silence,silence,Temporarily disables your most important equipment.|Can use two dice to unsilence.,,NO,YES,NO,NO,YES,/*as it turns out megaquest ALSO has a custom silence implementation for enemies... i think my 'most important card' thing is a bit nicer though. anyway i need to actually play megaquest some time; the betas i got of it were rather frustrating and unfair but my feedback probably helped*/ if(self.isplayer) { var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatus(\~ncr_silence\~|ALL); inflict(SILENCE); ~; tw.onComplete(s.execute|[target|self]); tw.move(); } else { self.symbolparticle(~silence~); },,,if(self.equipment.length > 0) {  var eqtosilence = null;  var eqstosort = [];  var exceptions = loaddata(~ncrmod/silenceexceptions~);  for(enemy in exceptions) { trace(self.name); trace(enemy.enemyname); if(self.name == enemy.enemyname) {   for(eq in self.equipment) { trace(enemy.importantcard); trace(eq.name); if(eq.name == enemy.importantcard) { eqstosort.push(eq); eqtosilence = eq; break; } }   if(eqtosilence == null) for(eq in self.equipment) if(eq.name == enemy.importantcard2) { eqstosort.push(eq); eqtosilence = eq; break; }  } }  if(eqtosilence == null) {   var never = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~never~) card.cardname];   var always = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~always~) card.cardname];   eqstosort = [for(eq in self.equipment) if(eq.isready() && never.indexOf(eq.name) == -1 && eq.shockedsetting != 2) eq];   var eqstosort2 = [];   if(eqstosort.length > 0) for(eq in eqstosort) if(always.indexOf(eq.name) != -1) eqstosort2.push(eq);   if(eqstosort2.length > 0) eqstosort = eqstosort2;   if(eqstosort.length == 1) eqtosilence = eqstosort[0];   if(eqtosilence == null && eqstosort.length > 0) {    var largeeqs = [for(eq in eqstosort) if(eq.size == 2) eq];    if(largeeqs.length > 0) eqstosort = largeeqs;    if(eqstosort.length == 1) eqtosilence = eqstosort[0];    if(eqtosilence == null) {     var sorton = ~~;     for(eq in eqstosort) {      if(eq.usesleft > 0 # (eq.usesleft == -1 && !eq.hastag(~hidereuseable~))) {       sorton = ~uses~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.countdown > 0) {       sorton = ~cd~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.getslots().length > 0 && !eq.getslots()[0].substr(0|7) == ~REQUIRE~) {       sorton = ~normal~; break;      }     }     if(sorton == ~~) sorton = ~needsx~;     trace(sorton);     var max = null;     if(sorton == ~normal~) max = eqstosort[0];     for(eq in eqstosort) {      if(sorton == ~uses~) {       if(eq.usesleft == -1) {        max = eq; break;       }       else if(max == null # eq.usesleft > max.usesleft) {        max = eq;       }      }      if(sorton == ~cd~) {       if(max == null # eq.countdown > max.countdown) {        max = eq;       }      }      if(sorton == ~needsx~) {       if(max == null # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (max.getslots.length == 0) # (max.getslots()[0].substr(0|7) != ~REQUIRE~)) # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (eq.getslots()[0].substr(7|0) - 0) > (max.getslots()[0].substr(7|0) - 0))) {        max = eq;       }      }     }     if(max != null) eqtosilence = max;    }   }  }  if(eqtosilence == null && eqstosort.length > 0) { trace(~what the fuck~); eqtosilence = eqstosort[0]; }  if(eqtosilence == null && eqstosort.length == 0) { trace(~what went on here~); eqtosilence = self.equipment[0]; }  if(getstatusself(~alternate_ncr_silence~) > 0) { eqtosilence.downgrade(); eqtosilence.animate(~flashandshake~); eqtosilence.animation[eqtosilence.animation.length - 1].addcommand(~textparticle~[;] ~[silence] Silenced!~[;] 16777215); sfx(~apply_silence_to_equipment~); } else if(getstatusself(~ncr_silence~) > 0) { eqtosilence.shockedsetting = 0; eqtosilence.animate(~silence~); } },,,,,,,
alternate_ncr_silence,Silence?!,silence,Temporarily weakens your most important equipment.|Equipment becomes less powerful.,,NO,YES,NO,NO,YES,if(self.isplayer) { var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatus(\~ncr_silence\~|ALL); inflict(\~alternate_silence\~); ~; tw.onComplete(s.execute|[target|self]); tw.move(); } else { self.symbolparticle(~silence~); },,,if(self.equipment.length > 0) {  var eqtosilence = null;  var eqstosort = [];  var exceptions = loaddata(~ncrmod/silenceexceptions~);  for(enemy in exceptions) { trace(self.name); trace(enemy.enemyname); if(self.name == enemy.enemyname) {   for(eq in self.equipment) { trace(enemy.importantcard); trace(eq.name); if(eq.name == enemy.importantcard) { eqstosort.push(eq); eqtosilence = eq; break; } }   if(eqtosilence == null) for(eq in self.equipment) if(eq.name == enemy.importantcard2) { eqstosort.push(eq); eqtosilence = eq; break; }  } }  if(eqtosilence == null) {   var never = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~never~) card.cardname];   var always = [for(card in loaddata(~ncrmod/silencecardexceptions~)) if(card.priority == ~always~) card.cardname];   eqstosort = [for(eq in self.equipment) if(eq.isready() && never.indexOf(eq.name) == -1 && eq.shockedsetting != 2) eq];   var eqstosort2 = [];   if(eqstosort.length > 0) for(eq in eqstosort) if(always.indexOf(eq.name) != -1) eqstosort2.push(eq);   if(eqstosort2.length > 0) eqstosort = eqstosort2;   if(eqstosort.length == 1) eqtosilence = eqstosort[0];   if(eqtosilence == null && eqstosort.length > 0) {    var largeeqs = [for(eq in eqstosort) if(eq.size == 2) eq];    if(largeeqs.length > 0) eqstosort = largeeqs;    if(eqstosort.length == 1) eqtosilence = eqstosort[0];    if(eqtosilence == null) {     var sorton = ~~;     for(eq in eqstosort) {      if(eq.usesleft > 0 # (eq.usesleft == -1 && !eq.hastag(~hidereuseable~))) {       sorton = ~uses~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.countdown > 0) {       sorton = ~cd~; break;      }     }     if(sorton == ~~) for(eq in eqstosort) {      if(eq.getslots().length > 0 && !eq.getslots()[0].substr(0|7) == ~REQUIRE~) {       sorton = ~normal~; break;      }     }     if(sorton == ~~) sorton = ~needsx~;     trace(sorton);     var max = null;     if(sorton == ~normal~) max = eqstosort[0];     for(eq in eqstosort) {      if(sorton == ~uses~) {       if(eq.usesleft == -1) {        max = eq; break;       }       else if(max == null # eq.usesleft > max.usesleft) {        max = eq;       }      }      if(sorton == ~cd~) {       if(max == null # eq.countdown > max.countdown) {        max = eq;       }      }      if(sorton == ~needsx~) {       if(max == null # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (max.getslots.length == 0) # (max.getslots()[0].substr(0|7) != ~REQUIRE~)) # (eq.getslots().length > 0 && eq.getslots()[0].substr(0|7) == ~REQUIRE~ && (eq.getslots()[0].substr(7|0) - 0) > (max.getslots()[0].substr(7|0) - 0))) {        max = eq;       }      }     }     if(max != null) eqtosilence = max;    }   }  }  if(eqtosilence == null && eqstosort.length > 0) { trace(~what the fuck~); eqtosilence = eqstosort[0]; }  if(eqtosilence == null && eqstosort.length == 0) { trace(~what went on here~); eqtosilence = self.equipment[0]; }  if(getstatusself(~alternate_ncr_silence~) > 0) { eqtosilence.downgrade(); eqtosilence.animate(~flashandshake~); eqtosilence.animation[eqtosilence.animation.length - 1].addcommand(~textparticle~[;] ~[silence] Silenced!~[;] 16777215); sfx(~apply_silence_to_equipment~); } else if(getstatusself(~ncr_silence~) > 0) { eqtosilence.shockedsetting = 0; eqtosilence.animate(~silence~); } },,,,,,,
vanishplus,Vanish+,vanish,Duplicate dice are immediately destroyed.|Original dice is also destroyed[;] for free.,,NO,YES,NO,NO,YES,var skipsetup = false; var noeffect = false; if(self.status.length > 0)  for(stat in self.status) {   if(stat.type == ~fadeplus~) skipsetup = true;   if(stat.type == ~vanishplus~) noeffect = true;  } if((self.getvar(~vanishactuator~) + 1 == ~SimpleActuator1~) # (target.getvar(~vanishactuator~) + 1 == ~SimpleActuator1~)) skipsetup = true; trace(skipsetup); trace(noeffect); if(skipsetup) trace(~skipping setup~); if(noeffect) { self.textparticle(~No effect!~); removestatusself(~fadeplus~|ALL); } else if(!skipsetup) {  trace(~starting vanish actuator~);  var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);  s.script = ~   if(self.hp <= 0 # self.graphic == null # target == null # target.graphic == null # target.hp <= 0) {    trace(\~vanish actuator stopped\~);    self.getvar(\~vanishactuator\~).stop();    self.resetvar(\~vanishactuator\~);   }   else {    if(self.dicepool.length > 0 && self.hasstatus(\~fadeplus\~)) {     var check1 = [false|false|false|false|false|false|false];     var check2 = [false|false|false|false|false|false|false];     var dicevanished = false;      for (i in 0 ... self.dicepool.length){       if (self.dicepool[i].available()){        if (!self.dicepool[i].intween()){         if (!check1[self.dicepool[i].basevalue]){          check1[self.dicepool[i].basevalue] = true;         }else{          check2[self.dicepool[i].basevalue] = true;         }        }       }      }      for (i in 0 ... self.dicepool.length){       if (self.dicepool[i].available()){        if (!self.dicepool[i].intween()){         if (check2[self.dicepool[i].basevalue]){          self.dicepool[i].animate(\~disappear\~);          dicevanished = true;          if(false){           trace(\~decrementing self vanish\~);           removestatusself(\~fade\~|1);           if(!self.hasstatus(\~fade\~)) { trace(\~breaking vanish for self\~); break; }          }          check1[self.dicepool[i].basevalue] = false;         }        }       }      }      if (dicevanished){       sfx(\~_diceburn\~);      }     }    if(target.dicepool.length > 0 && target.hasstatus(\~fadeplus\~)) {     var check1 = [false|false|false|false|false|false|false];     var check2 = [false|false|false|false|false|false|false];     var dicevanished = false;      for (i in 0 ... target.dicepool.length){       if (target.dicepool[i].available()){        if (!target.dicepool[i].intween()){         if (!check1[target.dicepool[i].basevalue]){          check1[target.dicepool[i].basevalue] = true;         }else{          check2[target.dicepool[i].basevalue] = true;         }        }       }      }      for (i in 0 ... target.dicepool.length){       if (target.dicepool[i].available()){        if (!target.dicepool[i].intween()){         if (check2[target.dicepool[i].basevalue]){          target.dicepool[i].animate(\~disappear\~);          dicevanished = true;          if(false){           trace(\~decrementing target vanish\~);           removestatus(\~fade\~|1);           if(!target.hasstatus(\~fade\~)) { trace(\~breaking vanish for target\~); break; }          }          check1[target.dicepool[i].basevalue] = false;         }        }       }      }      if (dicevanished){       sfx(\~_diceburn\~);      }     }   ~;   if(self.isplayer) s.execute(self|target); else s.execute(target|self);   if(self.isplayer) tw.onRepeat(s.execute|[self|target]); else tw.onRepeat(s.execute|[target|self]);   if(self.isplayer) self.setvar(~vanishactuator~|tw); else target.setvar(~vanishactuator~|tw);   tw.move(); },,,,,,,,,,
fadeplus,Fade+,vanish,Duplicate dice are immediately destroyed. Disappears when triggered.|Original dice is also destroyed[;] for free.,,YES,YES,NO,NO,YES,var skipsetup = false; var noeffect = false; if(self.status.length > 0)  for(stat in self.status) {   if(stat.type == ~fadeplus~) skipsetup = true;   if(stat.type == ~vanishplus~) noeffect = true;  } if((self.getvar(~vanishactuator~) + 1 == ~SimpleActuator1~) # (target.getvar(~vanishactuator~) + 1 == ~SimpleActuator1~)) skipsetup = true; trace(skipsetup); trace(noeffect); if(skipsetup) trace(~skipping setup~); if(noeffect) { self.textparticle(~No effect!~); removestatusself(~fadeplus~|ALL); } else if(!skipsetup) {  trace(~starting vanish actuator~);  var tw = new motion.actuators.SimpleActuator(null|1/60|null);  tw._repeat = -1;  var s = new elements.Skill(~Against all odds_old~);  s.script = ~   if(self.hp <= 0 # self.graphic == null # target == null # target.graphic == null # target.hp <= 0) {    trace(\~vanish actuator stopped\~);    self.getvar(\~vanishactuator\~).stop();    self.resetvar(\~vanishactuator\~);   }   else {    if(self.dicepool.length > 0 && self.hasstatus(\~fadeplus\~)) {     var check1 = [false|false|false|false|false|false|false];     var check2 = [false|false|false|false|false|false|false];     var dicevanished = false;      for (i in 0 ... self.dicepool.length){       if (self.dicepool[i].available()){        if (!self.dicepool[i].intween()){         if (!check1[self.dicepool[i].basevalue]){          check1[self.dicepool[i].basevalue] = true;         }else{          check2[self.dicepool[i].basevalue] = true;         }        }       }      }      for (i in 0 ... self.dicepool.length){       if (self.dicepool[i].available()){        if (!self.dicepool[i].intween()){         if (check2[self.dicepool[i].basevalue]){          self.dicepool[i].animate(\~disappear\~);          dicevanished = true;          if(!check1[self.dicepool[i].basevalue]){           trace(\~decrementing self vanish\~);           removestatusself(\~fade\~|1);           if(!self.hasstatus(\~fade\~)) { trace(\~breaking vanish for self\~); break; }          }          check1[self.dicepool[i].basevalue] = false;         }        }       }      }      if (dicevanished){       sfx(\~_diceburn\~);      }     }    if(target.dicepool.length > 0 && target.hasstatus(\~fadeplus\~)) {     var check1 = [false|false|false|false|false|false|false];     var check2 = [false|false|false|false|false|false|false];     var dicevanished = false;      for (i in 0 ... target.dicepool.length){       if (target.dicepool[i].available()){        if (!target.dicepool[i].intween()){         if (!check1[target.dicepool[i].basevalue]){          check1[target.dicepool[i].basevalue] = true;         }else{          check2[target.dicepool[i].basevalue] = true;         }        }       }      }      for (i in 0 ... target.dicepool.length){       if (target.dicepool[i].available()){        if (!target.dicepool[i].intween()){         if (check2[target.dicepool[i].basevalue]){          target.dicepool[i].animate(\~disappear\~);          dicevanished = true;          if(!check1[target.dicepool[i].basevalue]){           trace(\~decrementing target vanish\~);           removestatus(\~fade\~|1);           if(!target.hasstatus(\~fade\~)) { trace(\~breaking vanish for target\~); break; }          }          check1[target.dicepool[i].basevalue] = false;         }        }       }      }      if (dicevanished){       sfx(\~_diceburn\~);      }     }   ~;   if(self.isplayer) s.execute(self|target); else s.execute(target|self);   if(self.isplayer) tw.onRepeat(s.execute|[self|target]); else tw.onRepeat(s.execute|[target|self]);   if(self.isplayer) self.setvar(~vanishactuator~|tw); else target.setvar(~vanishactuator~|tw);   tw.move(); },,,,,,,,,,
alternate_vanishplus,Vanish?+,vanish,Whenever you use an equipment[;]|one of your unused dice will vanish.,,NO,YES,NO,NO,YES,,,,,if(self.dicepool.length > 0) { var dicelist = [for(dice in self.dicepool) if(dice.available() && !dice.intween()) dice]; if(dicelist.length > 0) { rand(dicelist).animate(~disappear~); sfx(~_vanish~); } },,,,,,
alternate_fadeplus,Fade?+,vanish,Whenever you use an equipment[;]|one of your unused dice will vanish. Disappears when triggered.,,YES,YES,NO,NO,YES,,,,,if(self.dicepool.length > 0) { var dicelist = [for(dice in self.dicepool) if(dice.available() && !dice.intween()) dice]; if(dicelist.length > 0) { rand(dicelist).animate(~disappear~); sfx(~_vanish~); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~);~; tw.onComplete(s.execute|[self|target]); tw.move(); } },,,,,,
ncr_chanced,Chanced,vanish,Upgrade all Vanish inflicted on you this turn.,,NO,YES,NO,NO,YES,,,,,,,,,,,
ncr_snap,Snap!,glove,Use a random equipment for free!|Applies immediately when inflicted[;] if possible[;]|or at the start of your turn.,Implemented by Black Widow.,YES,NO,NO,NO,NO,var snappableequipment = [for(eq in self.equipment) if(eq.onscreen() && eq.isready() && eq.skillcard == ~~ && eq.getslots().length > 0) eq]; var val = inflicted_value; var snapoccurred = false; if(snappableequipment.length > 0) shuffle(snappableequipment); while(val > 0) { if(snappableequipment.length == 0) break; runscript(~ncrmod/snap~|[snappableequipment.pop()|true]); val--; removestatusself(status.type); snapoccurred = true; },,,var snappableequipment = [for(eq in self.equipment) if(eq.onscreen() && eq.isready() && eq.skillcard == ~~ && eq.getslots().length > 0) eq]; var val = status.value; var snapoccurred = false; if(snappableequipment.length > 0) shuffle(snappableequipment); while(val > 0) { if(snappableequipment.length == 0) break; runscript(~ncrmod/snap~|[snappableequipment.pop()|true]); val--; removestatusself(status.type); snapoccurred = true; } if(snapoccurred) sfx(~jester_snap~);,,,,,,,
